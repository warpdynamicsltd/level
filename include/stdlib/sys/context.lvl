import stdlib:collections:stack as *;
import stdlib:sys:app as *;

type mem as rec
(
  var addr = null as ref(byte),
  var ref_count = 0 as int
)

method direct ()(mem, var size as int) as ref(mem)
{
  var this as ref(mem);
  this = app.allocator.allocate(sizeof(mem));
  this.addr = app.allocator.allocate(size);
  this.ref_count = 0;

  if (gc.global_stack != null)
  {
    exec gc.global_stack.push(this);
  }

  return this;
}

method direct del(var this as ref(mem))
{
  if (this.addr != null)
  {
    exec app.allocator.free(this.addr);
  }
  exec app.allocator.free(this);
}

type mem_obj as rec
(
  var m as ref(mem)
)

method direct ()(mem_obj, var size = 0 as int) as mem_obj
{
  var res as mem_obj;
  if (size == 0)
  {
    res.m = null;
    return res;
  }

  res.m = mem(size);
  res.m.ref_count = 0;

  return res;
}

method direct ptr(var this as ref(mem_obj), A) as ref(A)
{
  return (ref(A))(this.m.addr);
}

method direct del(var this as ref(mem_obj))
{
  # echo "deleting ...";
  if (this.m != null and this.m.ref_count > 0)
  {
    dec this.m.ref_count;
#    if (this.m.ref_count == 0)
#    {
#      #del this.m;
#      #this.m.ref_count = -1;
#      exec app.allocator.free(this.m.addr);
#      this.m.addr = null;
#      this.m.ref_count = -1;
#
#    }
    # echo "ref count after deletion";
    # echo this.m.ref_count;
  }

  #this.m = null;
}

method direct =(var this as ref(mem_obj), var a as ref(mem_obj))
{
  # echo "=";
  if (this.m != null)
  {
    del this;
  }

  this.m = a.m;
  inc this.m.ref_count;
}

type GC as rec
(
  var global_stack as ref(Stack(ref(mem))),
)

method direct ()(GC) as GC
{
  var res as GC;
  res.global_stack = Stack(ref(mem))();
  return res;
}

method collect(var this as ref(GC))
{
  if (gc.global_stack != null and gc.global_stack.length() > 0)
  {
    stack = Stack(ref(mem))();
    foreach(var m as ref(mem) in gc.global_stack)
    {
#      echo ".";
#      echo m.ref_count;
      if (m.ref_count <= 0)
      {
        del m;
      }
      else
      {
        exec stack.push(m);
      }

    }
    del gc.global_stack;
    gc.global_stack = stack;
  }
}

method direct clear(var this as ref(GC))
{
  del this.global_stack;
  this.global_stack = null;
}

global gc = GC() as GC;

sub direct on_opening()
{
  #echo "opening";
  #var stack = Stack(ref(mem))();
  #exec gc.global_stack.push(stack);
}

sub direct on_closing()
{
  exec gc.collect();
}
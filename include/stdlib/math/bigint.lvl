import stdlib:obj:collections:vector as *;
import stdlib:obj:collections:stack as *;
import stdlib:obj:collections:str as *;

type bigint extends object with rec
(
  var data as vector(u64),
  var sign = 1 as byte
);

method new ()(bigint, var n = 0 as u64) as bigint
{
  var this as bigint;
  this.data = vector(u64)(1);
  this.data[0] = n;
  this.sign = 1;
  return this;
}

method new()(bigint, var n = 0 as int) as bigint
{
  var this as bigint;
  this.data = vector(u64)(1);
  if (n < 0)
  {
    this.sign = -1;
  }
  this.data[0] = abs(n);
  return this;
}

method new ()(bigint, var st as ref(stack(u64))) as bigint
{
  var res as bigint;
  res.data = vector(u64)(st.length());
  i = 0;
  foreach (var u as u64 in st)
  {
    res.data[i] = u;
    inc i;
  }

  return res;
}

method new +(var this as ref(bigint), var other as ref(bigint)) as bigint
{
  var r as u64;
  var c as u64;
  var a as u64;
  var b as u64;

  var res as bigint;

  st = stack(u64)();

  this_len = this.data.length();
  other_len = other.data.length();
  end_a = false;
  end_b = false;

  i = 0;
  c = 0;
  while (not(end_a and end_b))
  {
    if (i < this_len)
    {
      a = this.data[i];
    }
    else
    {
      a = 0;
      end_a = true;
    }

    if (i < other_len)
    {
      b = other.data[i];
    }
    else
    {
      b = 0;
      end_b = true;
    }

    r = __api__(add, a, b, c);
    if (r == 0 and end_a and end_b)
    {
      break;
    }
    exec st.push(r);

    inc i;
  }

  return bigint(ref st);
}

sub new mul(var a as u64, var b as u64) as bigint
{
  var res as bigint;
  var r as u64;
  var d as u64;
  r = __api__(mul, a, b, d);
  if (d == 0)
  {
    res.data = vector(u64)(1);
    res.data[0] = r;
  }
  else
  {
    res.data = vector(u64)(2);
    res.data[0] = r;
    res.data[1] = d;
  }

  return res;
}

method new normalise(var this as ref(bigint)) as bigint
{
  i = this.data.length();
  while(i > 0 and this.data[i - 1] == 0)
  {
    dec i;
  }
  var res as bigint;
  res.data = vector(u64)(i);
  for(j = 0; j < i; inc j)
  {
    res.data[j] = this.data[j];
  }

  return res;
}

method new lshift(var this as ref(bigint), var n as int) as bigint
{
  var res as bigint;
  len = this.data.length();
  res.data = vector(u64)(len + n);
  for (i = 0; i < n; inc i)
  {
    res.data[i] = 0;
  }
  for (i = 0; i < len; inc i)
  {
    res.data[n + i] = this.data[i];
  }
  return res;
}

sub new slow_mul(var a as ref(bigint), var b as ref(bigint)) as bigint
{
  res = bigint(0x0);
  n = a.data.length();
  m = b.data.length();
  for (i = 0; i < n; inc i)
  {
    for (j = 0; j < m; inc j)
    {
      res = res + mul(a.data[i], b.data[j]).lshift(i + j);
    }
  }

  return res.normalise();
}

method new *(var this as ref(bigint), var a as ref(bigint)) as bigint
{
  return slow_mul(this, a);
}

method =(var this as ref(bigint), var a as ref(bigint))
{
  this.data = a.data;
  this.sign = a.sign;
}

method del (var this as ref(bigint))
{
  del this.data;
}

method finish(var this as ref(bigint))
{
  del this;
}

method echo (var this as ref(bigint))
{
  res = str();
  for (i = this.data.length() - 1; i >= 0; dec i)
  {
    res = res + hex64(this.data[i]);
  }
  echo res;
}